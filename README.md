# **БАЗА** по Базам

---

## 1. Понятие СУБД. Функции СУБД. Отличие от хранения в таблицах

**СУБД (Система управления базами данных)** — это программное обеспечение для создания, управления, модификации и защиты БД.

### Основные функции СУБД:
- Хранение, добавление, изменение, удаление данных
- Управление транзакциями (атомарность, согласованность, изолированность, долговечность — ACID)
- Обеспечение целостности данных (ограничения, ключи)
- Защита и управление доступом (роли, права)
- Резервное копирование и восстановление
- Механизмы журналирования (лог WAL в PostgreSQL)

**Отличия от хранения в таблицах (например, Excel):**
| Характеристика      | СУБД (PostgreSQL)            | Таблицы (Excel, Google Sheets) |
|---------------------|------------------------------|-------------------------------|
| Целостность данных  | Да (ограничения, ключи)      | Нет                           |
| Одновременная работа| Да (многопользовательская)    | Ограничено                    |
| Масштабируемость    | Высокая                       | Низкая                        |
| Безопасность        | Гибкое управление доступом    | Простое или отсутствует       |
| Язык запросов       | SQL                           | Нет                           |

---

## 2. Трехуровневая архитектура ANSI-SPARC

Позволяет отделить логику представления данных от их физического хранения:

1. **Внешний уровень** — представление данных для пользователя (view).
2. **Концептуальный уровень** — логическая модель всех данных, описание сущностей и связей.
3. **Внутренний уровень** — физическая реализация (файлы, индексы, способы хранения).

**Преимущества**:
- Независимость данных
- Гибкость при изменениях на любом уровне

---

## 3. Языки БД. DDL, DML

**SQL** — язык взаимодействия с БД. Делится на несколько категорий:

- **DDL (Data Definition Language)** — определение структуры БД:
  - `CREATE`, `ALTER`, `DROP`, `TRUNCATE`

- **DML (Data Manipulation Language)** — управление данными:
  - `SELECT`, `INSERT`, `UPDATE`, `DELETE`

- Также выделяют:
  - **DCL (Data Control Language)** — управление доступом: `GRANT`, `REVOKE`
  - **TCL (Transaction Control Language)** — управление транзакциями: `BEGIN`, `COMMIT`, `ROLLBACK`

---

## 4. Понятие ключа

**Ключ** — набор атрибутов, однозначно идентифицирующих строку в таблице.

- **Потенциальный ключ** — любой минимальный уникальный набор полей.
- **Первичный ключ (PRIMARY KEY)** — выбранный потенциальный ключ.
- **Альтернативный ключ** — потенциальный ключ, не ставший первичным.
- **Составной ключ** — ключ из нескольких атрибутов.
- **Внешний ключ (FOREIGN KEY)** — ссылка на первичный ключ другой таблицы, обеспечивает ссылочную целостность.

---

## 5. «Сущность – связь». ER-модель

**Сущность** — объект предметной области (например, `Student`).  
**Связь (relationship)** — логическая ассоциация между сущностями (например, `enrolled_in`).

### Типы связей:
- **1:1** — один к одному (например, `Person` — `Passport`)
- **1:N** — один ко многим (например, `Department` — `Employee`)
- **M:N** — многие ко многим (например, `Student` — `Course`)

### ER-модели:
- **Crow's Foot (вороний клюв)** — обозначает кратности и обязательность
- **IDEF1X** — фокусируется на ключах и отношениях, применяется в проектировании БД

---

## 6. Нормализация. Цель и аномалии

**Нормализация** — процесс приведения структуры таблиц к форме, устраняющей избыточность и аномалии.

### Цель:
- Минимизировать избыточность данных
- Устранить **аномалии вставки, удаления, обновления**

**Пример аномалий**:
- Вставка невозможна без дополнительной информации
- Удаление строки удаляет важные данные
- Обновление требует изменить значение в нескольких местах

---

## 7. Функциональные зависимости и 1НФ, 2НФ

### Функциональная зависимость:
`A → B`, если по значению A однозначно определяется B.

### Нормальные формы:
- **1НФ** — все атрибуты атомарны (нет повторяющихся или вложенных полей)
- **2НФ** — 1НФ + каждый неключевой атрибут полностью функционально зависит от первичного ключа (не только от части составного ключа)

**Пример нарушения 2НФ**: если `StudentID, CourseID` → `Grade`, но `StudentName` зависит только от `StudentID`

---

## 8. 3НФ, OLTP и OLAP, достоинства и недостатки нормализации

### 3НФ (Третья нормальная форма):
- Таблица в 2НФ
- Нет **транзитивных зависимостей** между неключевыми атрибутами:
  - если `A → B` и `B → C`, то `A → C` — плохо
- **Транзитивная зависимость** возникает, когда неключевой атрибут зависит не от первичного ключа, а от другого неключевого атрибута.

### OLTP (Online Transaction Processing): 
Технология обработки транзакций в базах данных, ориентированная на быструю и эффективную работу с большим количеством коротких операций в реальном времени.
- Системы для обработки повседневных транзакций
- Много операций INSERT, UPDATE, DELETE
- Требует высокой нормализации

### OLAP (Online Analytical Processing):
Технология обработки данных, предназначенная для сложного анализа больших объемов информации, построения отчетов и бизнес-аналитики.
- Анализ больших объемов данных
- Много операций SELECT, агрегирования
- Использует денормализованные схемы (звезда, снежинка)

### Достоинства нормализации:
- Минимизация избыточности
- Устранение аномалий
- Повышение целостности данных

### Недостатки:
- Сложность запросов (много JOIN'ов)
- Потеря производительности в аналитике


## 9. Простые запросы. Оператор SELECT. Синтаксис. Вычисляемые столбцы. Именование столбца

**SELECT** — основной оператор для извлечения данных из таблиц.

### Синтаксис:
```sql
SELECT [столбцы или выражения]
FROM имя_таблицы;
````

### Пример:

```sql
SELECT name, age FROM students;
```

### Вычисляемые столбцы:

Можно выполнять арифметические операции и использовать функции:

```sql
SELECT name, age + 1 AS age_next_year FROM students;
```

### Именование столбцов:

* `AS` позволяет задать читаемое имя столбца
* Альтернативно можно просто указать имя без `AS`

```sql
SELECT name || ' ' || surname AS full_name FROM students;
```

---

## 10. Выборка строк. Конструкция WHERE

**WHERE** — фильтрация строк по условию.

### Примеры:

```sql
SELECT * FROM students WHERE age > 20;
SELECT * FROM students WHERE name = 'Alice';
SELECT * FROM students WHERE age BETWEEN 18 AND 22;
SELECT * FROM students WHERE name LIKE 'A%';  -- имена на А
SELECT * FROM students WHERE email IS NULL;
```

> ⚠ `=` — для точного сравнения, `LIKE` — для шаблонов, `IS NULL` — проверка на NULL

---

## 11. Сортировка результатов. Конструкция ORDER BY

**ORDER BY** — задаёт порядок вывода строк.

### Примеры:

```sql
SELECT * FROM students ORDER BY age;             -- по возрастанию
SELECT * FROM students ORDER BY age DESC;        -- по убыванию
SELECT * FROM students ORDER BY age, name;       -- сначала по возрасту, затем по имени
```

---

## 12. Использование агрегирующих функций языка SQL

Агрегатные функции обрабатывают группы строк и возвращают одно значение.

| Функция   | Назначение       |
| --------- | ---------------- |
| `COUNT()` | Количество строк |
| `SUM()`   | Сумма значений   |
| `AVG()`   | Среднее значение |
| `MAX()`   | Максимум         |
| `MIN()`   | Минимум          |

COUNT(*) считает все строки, с учетом NULL.

COUNT(column) считает только не-NULL значения в указаном столбце.

Все остальные NULL игнорируют. Если все значения NULL, то результат NULL.

### Примеры:

```sql
SELECT COUNT(*) FROM students;
SELECT AVG(age) FROM students WHERE age IS NOT NULL;
SELECT MAX(age), MIN(age) FROM students;
```

---

## 13. Группирование результатов. GROUP BY и HAVING

**GROUP BY** — группировка строк по значению столбца.
**HAVING** — фильтрация групп (как WHERE, но после группировки).

### Пример:

```sql
SELECT age, COUNT(*) AS num_students
FROM students
GROUP BY age;
```

### С использованием HAVING:

```sql
SELECT age, COUNT(*) AS num_students
FROM students
GROUP BY age
HAVING COUNT(*) > 3;
```

---

## 14. Подзапросы

Подзапрос — вложенный SELECT, может использоваться:

* В выражении `WHERE`, `FROM`, `SELECT`
* Возвращать скалярное, строчное или табличное значение

### Примеры:

```sql
-- Студенты с максимальным возрастом
SELECT * FROM students
WHERE age = (SELECT MAX(age) FROM students);

-- Подзапрос в FROM (inline view)
SELECT avg_age FROM (
    SELECT AVG(age) AS avg_age FROM students
) AS sub;
```

---

## 15. Многотабличные запросы. Псевдонимы таблиц

Псевдонимы таблиц делают запросы короче и удобнее.

### Пример:

```sql
SELECT s.name, d.name
FROM students AS s
JOIN departments AS d ON s.department_id = d.id;
```

---

## 16. Многотабличные запросы. Выполнение соединений (JOIN)

В PostgreSQL есть несколько видов соединений:

| Вид JOIN     | Назначение                            |
| ------------ | ------------------------------------- |
| `INNER JOIN` | Только совпадающие строки             |
| `LEFT JOIN`  | Все из левой, + совпадающие из правой |
| `RIGHT JOIN` | Все из правой, + совпадающие из левой |
| `FULL JOIN`  | Все строки обеих таблиц               |
| `CROSS JOIN` | Декартово произведение                |

### Пример INNER JOIN:

```sql
SELECT s.name, d.name AS department
FROM students s
JOIN departments d ON s.department_id = d.id;
```

---

## 17. Комбинирование результирующих таблиц. UNION, INTERSECT, EXCEPT

Работают с SELECT-запросами с одинаковым числом и типом столбцов.

| Оператор    | Описание                             |
| ----------- | ------------------------------------ |
| `UNION`     | Объединение без повторов             |
| `UNION ALL` | Объединение с повторами              |
| `INTERSECT` | Общие строки                         |
| `EXCEPT`    | Разность (в первом, но не во втором) |

### Пример:

```sql
SELECT name FROM students
UNION
SELECT name FROM teachers;
```

---

## 18. Изменение содержимого БД. Операция UPDATE

**UPDATE** — изменяет существующие строки.

### Синтаксис:

```sql
UPDATE таблица
SET столбец = выражение [, ...]
WHERE условие;
```

### Пример:

```sql
UPDATE students
SET age = age + 1
WHERE name = 'Alice';
```

> ⚠ Без `WHERE` изменятся все строки!

---

## 19. Изменение содержимого БД. Операции INSERT, DELETE

### INSERT — добавление новых строк:

```sql
INSERT INTO students (name, age) VALUES ('Bob', 20);
```

* Можно добавить несколько строк:

```sql
INSERT INTO students (name, age)
VALUES ('Tom', 19), ('Lisa', 22);
```

### DELETE — удаление строк:

```sql
DELETE FROM students WHERE age < 18;
```

> ⚠ Без `WHERE` удалятся **все строки**:

```sql
DELETE FROM students;
```

## 20. Язык SQL. Определение данных. Типы данных

Язык определения данных (DDL) используется для создания и модификации структуры БД.

### Основные типы данных в PostgreSQL:

#### 🔢 Числовые типы:
- `INTEGER`, `SMALLINT`, `BIGINT` — целые числа
- `NUMERIC(p,s)` — точные десятичные числа (p — точность, s — масштаб)
- `REAL`, `DOUBLE PRECISION` — числа с плавающей точкой

#### 📝 Строковые типы:
- `TEXT` — строка произвольной длины
- `VARCHAR(n)` — строка до `n` символов
- `CHAR(n)` — строка фиксированной длины `n`

#### 📅 Дата и время:
- `DATE`, `TIME`, `TIMESTAMP`, `INTERVAL`

#### 🔘 Логический тип:
- `BOOLEAN` — `TRUE`, `FALSE`, `NULL`

#### 🆔 Другие типы:
- `SERIAL` — автоинкрементное целое число
- `UUID` — универсальный уникальный идентификатор
- `BYTEA` — бинарные данные

---

## 21. Средства поддержки целостности

Целостность данных (Data Integrity) — это точность, непротиворечивость и надежность данных в базе на протяжении всего их жизненного цикла. Она гарантирует, что данные остаются корректными и соответствуют бизнес-правилам даже после изменений.

- Физическая целостность - защита данных от аппратных сбоев, повреждений, потери.
- Логическая целостность - правильность данных с точки зрения бизнес-логики.

### 🔹 Обязательные данные:
- `NOT NULL` — значение обязательно
```sql
name TEXT NOT NULL
````

### 🔹 Ограничения для доменов:

* `CHECK` — проверка значения

```sql
age INTEGER CHECK (age >= 0)
```

### 🔹 Целостность сущностей:

* Каждая строка в таблице должна быть уникально определена
* Обеспечивается **PRIMARY KEY** — не допускает NULL и дублирование

### 🔹 Ссылочная целостность:

* Обеспечивается **FOREIGN KEY** — значения должны ссылаться на существующие строки другой таблицы

```sql
FOREIGN KEY (department_id) REFERENCES departments(id)
```

### 🔹 Семантическая целостность:

* Бизнес-правила уровня приложения, поддерживаются через `CHECK`, `TRIGGER`, хранимые процедуры

---

## 22. Создание БД. Создание таблиц. (Схемы. Табличные пространства)

### 🔹 Создание базы данных:

```sql
CREATE DATABASE university;
```

Подключение к базе:

```sql
\c university
```

---

### 🔹 Схемы (schemas)

**Схема** — логическое объединение объектов базы данных (таблиц, представлений, функций и др.).

По умолчанию в PostgreSQL используется схема `public`.

Создание схемы:

```sql
CREATE SCHEMA education;
```

Создание таблицы в конкретной схеме:

```sql
CREATE TABLE education.students (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    age INTEGER CHECK (age > 0)
);
```

Обращение к таблице в другой схеме:

```sql
SELECT * FROM education.students;
```

---

### 🔹 Табличные пространства (tablespaces)

**Табличное пространство** — физическое расположение данных на диске.

Создание табличного пространства:

```sql
CREATE TABLESPACE fastspace LOCATION '/mnt/ssd1';
```

Создание таблицы с указанием табличного пространства:

```sql
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    name TEXT,
    age INTEGER
) TABLESPACE fastspace;
```

> Табличные пространства используются для управления размещением данных и оптимизации производительности.

---

### 🔹 Создание таблиц:

```sql
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    age INTEGER CHECK (age >= 0),
    department_id INTEGER REFERENCES departments(id)
);
```

Дополнительно:

* `SERIAL` — автоинкрементное поле (аналог `AUTO_INCREMENT`)
* `NOT NULL`, `CHECK`, `FOREIGN KEY` — ограничения для обеспечения целостности

---


## 23. Именованные ограничения. Особенности создания таблиц

Позволяют давать ограничениям имена для управления ими в будущем.

### Пример:

```sql
CREATE TABLE students (
    id SERIAL CONSTRAINT pk_students PRIMARY KEY,
    age INTEGER CONSTRAINT check_age CHECK (age >= 0),
    name TEXT CONSTRAINT nn_name NOT NULL
);
```

Особенности:

* Именованные ограничения можно удалять:

  ```sql
  ALTER TABLE students DROP CONSTRAINT check_age;
  ```
* Возможность переиспользовать и ссылаться по имени

---

## 24. Операторы DDL в языке SQL с заданием ограничений целостности

Пример полной таблицы с ограничениями:

```sql
CREATE TABLE courses (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    credits INTEGER CHECK (credits BETWEEN 1 AND 10),
    teacher_id INTEGER NOT NULL,
    UNIQUE (name, teacher_id),
    FOREIGN KEY (teacher_id) REFERENCES teachers(id)
);
```

Ограничения можно добавлять отдельно:

```sql
ALTER TABLE courses ADD CONSTRAINT fk_teacher
FOREIGN KEY (teacher_id) REFERENCES teachers(id);
```

---

## 25. Средства изменения описания и удаления таблиц

### Изменение таблицы:

```sql
ALTER TABLE students ADD COLUMN email TEXT;
ALTER TABLE students DROP COLUMN email;
ALTER TABLE students RENAME TO learners;
ALTER TABLE students RENAME COLUMN name TO full_name;
```

### Удаление таблицы:

```sql
DROP TABLE students;
DROP TABLE IF EXISTS students CASCADE; -- с зависимостями
```

---

## 26. Табличное пространство

**Табличное пространство (tablespace)** — это место на диске, где физически хранятся объекты БД.

### Создание:

```sql
CREATE TABLESPACE fastspace LOCATION '/mnt/ssd1';
```

### Применение:

```sql
CREATE TABLE logs (
    id SERIAL,
    message TEXT
) TABLESPACE fastspace;
```

> Позволяет распределять нагрузку, например: важные таблицы — на быстрых SSD, архивы — на HDD

---

## 30-31. Триггеры 
Скип

---

## 27. Представление. Создание представлений. Типы представлений

**Представление (view)** — логическая таблица, создаваемая на основе SQL-запроса. Представления не хранят данные, а отображают их из базовых таблиц.

### 🔹 Создание представления

```sql
CREATE VIEW young_students AS
SELECT id, name, age
FROM students
WHERE age < 25;
```

Обращение к представлению:

```sql
SELECT * FROM young_students;
```

---

### 🔹 Типы представлений

1. **Обычное (логическое)** — не хранит данные, отображает результаты запроса.
2. **Материализованное (materialized view)** — хранит результаты запроса, может обновляться вручную.

Пример материализованного представления:

```sql
CREATE MATERIALIZED VIEW student_count_per_dept AS
SELECT department_id, COUNT(*) AS student_count
FROM students
GROUP BY department_id;
```

Обновление:

```sql
REFRESH MATERIALIZED VIEW student_count_per_dept;
```

---

## 28. Представление. Конструкция WITH CHECK OPTION. Обновление данных в представлении

### 🔹 Обновление данных через представление

Обновление возможно **только** если представление однозначно отображается на одну таблицу и не содержит агрегатов, группировки и т.д.

```sql
UPDATE young_students
SET age = 26
WHERE id = 1;
```

Если условие `age < 25` нарушается, строка **исчезает** из представления.

---

### 🔹 WITH CHECK OPTION

Обеспечивает, что обновляемые/вставляемые строки **соответствуют условию представления**.

```sql
CREATE VIEW underage_students AS
SELECT * FROM students
WHERE age < 18
WITH CHECK OPTION;
```

Теперь нельзя вставить/обновить данные, если `age >= 18`.

---

## 29. Представление. Преимущества и недостатки представлений. Материализация представлений

### ✅ Преимущества представлений:

* Повышение читаемости запросов (инкапсуляция логики)
* Повторное использование запросов
* Повышение безопасности (ограничение доступа к конкретным столбцам)
* Абстракция от сложной структуры БД

---

### ❌ Недостатки представлений:

* Сложность обновления (особенно при JOIN, GROUP BY)
* Может замедлить работу, если используется часто и не оптимизировано
* Не всегда допускается `INSERT`, `UPDATE`, `DELETE`

---

### 🔹 Материализованные представления

Материализованное представление — физическая копия данных на момент создания.

**Плюсы:**

* Быстрый доступ к данным (особенно при сложных запросах и агрегациях)
* Снижение нагрузки на базовые таблицы

**Минусы:**

* Данные устаревают — нужно вручную выполнять `REFRESH`
* Занимают физическое место в БД

```sql
REFRESH MATERIALIZED VIEW view_name;
```

---

## 32. Хранимые процедуры

**Хранимая процедура** — это блок кода, который выполняется на сервере и может выполнять **последовательность SQL-команд**, включая изменения данных и управление транзакциями.

> В PostgreSQL хранимые процедуры появились с версии 11. Они **не возвращают значения**, в отличие от функций.

### 🔹 Создание процедуры:

```sql
CREATE PROCEDURE log_and_insert(student_name TEXT, student_age INT)
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO log_table(action) VALUES ('Добавление студента');
    INSERT INTO students(name, age) VALUES (student_name, student_age);
END;
$$;
```

### 🔹 Вызов процедуры:

```sql
CALL log_and_insert('Иван', 20);
```

### 🔹 Отличия от функций:

* Процедуры вызываются с помощью `CALL`
* Не возвращают значения
* Могут выполнять `COMMIT`, `ROLLBACK`, работать с транзакциями

---

## 33. Функции. Назначение. Параметры и возвращаемые значения. Категории изменчивости

**Функция** — это объект БД, выполняющий вычисление и возвращающий результат (одиночное значение, строку или таблицу).

Используются:

* для инкапсуляции логики
* в SELECT-запросах
* как часть бизнес-логики

---

### 🔹 Создание функции:

```sql
CREATE FUNCTION square(x INTEGER) RETURNS INTEGER
LANGUAGE SQL
AS $$
    SELECT x * x;
$$;
```

### 🔹 С параметрами и возвращаемыми значениями:

```sql
CREATE FUNCTION get_student_age(student_id INT) RETURNS INT
LANGUAGE plpgsql
AS $$
DECLARE
    result INT;
BEGIN
    SELECT age INTO result FROM students WHERE id = student_id;
    RETURN result;
END;
$$;
```

Вызов:

```sql
SELECT get_student_age(1);
```

---

### 🔹 Категории изменчивости (volatility categories)

PostgreSQL требует указывать **тип изменчивости** — насколько результат функции зависит от состояния БД.

| Категория   | Описание                                                                                               |
| ----------- | ------------------------------------------------------------------------------------------------------ |
| `IMMUTABLE` | Результат зависит только от входных параметров. Например: `ABS(x)`                                     |
| `STABLE`    | Зависит от данных в БД, но не изменяется в рамках одного запроса. Например: `SELECT count(*) FROM ...` |
| `VOLATILE`  | Может возвращать разные результаты даже при одинаковых входных данных. Например: `random()`, `now()`   |

Пример:

```sql
CREATE FUNCTION random_multiplier(x INT) RETURNS INT
VOLATILE
LANGUAGE SQL
AS $$
    SELECT x * FLOOR(RANDOM() * 10)::INT;
$$;
```

---

## 34. РЕЯЛЦИОННАЯ АЛГЕБРА

**Реляционная алгебра** — это формальный язык манипулирования данными в реляционных базах данных. Она определяет базовые операции над отношениями (таблицами) и позволяет выразить любые запросы к БД.

Все операции в реляционной алгебре принимают **отношения (таблицы)** как вход и возвращают **новые отношения** как результат.

---

### 🔹 Основные понятия:

- **Отношение (relation)** — это таблица с уникальными строками (кортежами).
- **Кортеж (tuple)** — строка в таблице.
- **Атрибут (attribute)** — столбец в таблице.
- Результатом любой операции реляционной алгебры является **новая таблица** (замкнутость).

---

## 🔸 Основные операции реляционной алгебры

---

### 1. **Проекция (π)**

Извлечение **нужных столбцов** из отношения.

**Синтаксис:**  
`π<атрибуты>(R)`

**Пример:**  
`π<name, age>(Students)`  
Выбрать только `name` и `age` из таблицы `Students`.

**Аналог SQL:**
```sql
SELECT name, age FROM Students;
```

---

### 2. **Селекция/Выборка (σ)**

Выбор строк, удовлетворяющих **условию**.

**Синтаксис:**
`σ<условие>(R)`

**Пример:**
`σ<age > 18>(Students)`
Выбрать студентов старше 18.

**Аналог SQL:**

```sql
SELECT * FROM Students WHERE age > 18;
```

---

### 3. **Объединение (∪)**

Объединяет кортежи из двух таблиц **с одинаковым числом и типами столбцов**.

**Синтаксис:**
`R ∪ S`

**Пример:**
`π<name>(Graduates) ∪ π<name>(Students)`
Объединение всех имён студентов и выпускников.

**Аналог SQL:**

```sql
SELECT name FROM Graduates
UNION
SELECT name FROM Students;
```

---

### 4. **Пересечение (∩)**

Оставляет **общие строки** из двух таблиц.

**Синтаксис:**
`R ∩ S`

**Аналог SQL:**

```sql
SELECT name FROM A
INTERSECT
SELECT name FROM B;
```

---

### 5. **Разность (−)**

Оставляет строки, которые есть в одной таблице, но **отсутствуют в другой**.

**Синтаксис:**
`R − S`

**Пример:**
`π<name>(Students) − π<name>(Graduates)`
Студенты, которые ещё не выпускники.

**Аналог SQL:**

```sql
SELECT name FROM Students
EXCEPT
SELECT name FROM Graduates;
```

---

### 6. **Декартово произведение (×)**

Создаёт все возможные пары строк из двух таблиц.

**Синтаксис:**
`R × S`

**Пример:**
`Students × Courses`
Каждому студенту сопоставляются все курсы.

**Аналог SQL:**

```sql
SELECT * FROM Students, Courses;
```

> Используется как основа для соединений.

---

## 🔸 Расширенные операции реляционной алгебры

---

### 7. **Соединение (⨝ — join)**

Объединяет строки из двух таблиц по **связанным атрибутам**.

**Синтаксис:**
`R ⨝<условие> S`

**Пример:**
`Students ⨝ Students.department_id = Departments.id Departments`

**Аналог SQL:**

```sql
SELECT * FROM Students
JOIN Departments ON Students.department_id = Departments.id;
```

---

### 8. **Естественное соединение (⋈)**

Автоматически соединяет таблицы **по общим атрибутам с одинаковыми именами**.

**Синтаксис:**
`R ⋈ S`

**Пример:**
Если в обеих таблицах есть `dept_id`, произойдёт соединение по нему.

---

### 9. **Разделение (÷ — division)**

Находит такие строки из первой таблицы, которым **соответствуют все строки из второй таблицы**.

**Синтаксис:**
`R ÷ S`

**Пример:**
Найти студентов, которые сдали **все экзамены**:

* `R(StudentID, ExamID)` — кто что сдал
* `S(ExamID)` — какие экзамены нужно сдать

```text
R ÷ S = студенты, сдавшие все экзамены из S
```

**В SQL реализуется сложно**, часто через `GROUP BY`, `HAVING` и `NOT EXISTS`.

---

## 🔸 Пример полного запроса на реляционной алгебре

**Задача:** Найти имена студентов, обучающихся на факультете "Math", которым больше 18 лет.

Пусть:

* `Students(StudentID, Name, Age, DeptID)`
* `Departments(DeptID, DeptName)`

**Реляционная алгебра:**

```text
σ<DeptName = 'Math'>(Departments) ⨝ Students
→ π<Name>(σ<Age > 18>(...))
```

**Аналог SQL:**

```sql
SELECT s.name
FROM Students s
JOIN Departments d ON s.dept_id = d.dept_id
WHERE d.deptname = 'Math' AND s.age > 18;
```

---

## 35. Индексы

### 🔹 Назначение индексов

**Индекс** — это специальная структура данных, которая ускоряет поиск строк в таблице по значению одного или нескольких столбцов.

> Аналогично указателю в книге: индекс позволяет найти нужную строку без полного перебора таблицы.

---

### 🔹 Достоинства индексов

- 📈 **Ускорение запросов** с условиями `WHERE`, сортировками (`ORDER BY`) и соединениями.
- 🧠 **Повышение производительности** при использовании агрегатных функций или фильтрации по диапазонам.
- 🔄 **Ускорение JOIN-ов** по индексированным полям.

---

### 🔹 Недостатки индексов

- 📦 **Дополнительное место на диске**
- 🐢 **Замедление операций вставки, обновления и удаления**: при изменении данных нужно обновлять и индекс.
- 🔍 **Неправильный выбор индекса может не ускорить, а замедлить запрос**.

---

### 🔹 Создание индекса

```sql
CREATE INDEX idx_students_name
ON Students(name);
```

Можно также создавать составной индекс:

```sql
CREATE INDEX idx_students_name_age
ON Students(name, age);
```

---

### 🔹 Удаление индекса

```sql
DROP INDEX idx_students_name;
```

---

## 36. Виды индексов. Рекомендации по созданию

PostgreSQL поддерживает несколько видов индексов, каждый подходит для разных типов запросов и данных.

---

### 🔸 1. **B-Tree (по умолчанию)**

* 🟢 Подходит для: точного поиска, поиска по диапазону, `ORDER BY`
* 📌 Типичный индекс для чисел, дат, строк

```sql
CREATE INDEX ON Students(age); -- по умолчанию B-Tree
```

---

### 🔸 2. **Hash**

* 🔍 Только для точного соответствия (`=`), **не поддерживает сортировку** и диапазоны.
* Быстрее, чем B-Tree, для равенства, но используется редко.

```sql
CREATE INDEX idx_hash_name ON Students USING HASH(name);
```

---

### 🔸 3. **GIN (Generalized Inverted Index)**

* 🧠 Используется для массивов, JSONB, `tsvector` (полнотекстовый поиск).
* Поддерживает **поиск вхождения элемента** в массив, наличие ключей и значений в JSONB.

```sql
CREATE INDEX idx_jsonb_data ON documents USING GIN(data);
```

---

### 🔸 4. **GiST (Generalized Search Tree)**

* 📏 Подходит для географических данных, поиска по диапазонам и подобию (`LIKE`, расстояние).
* Используется в расширении PostGIS.

```sql
CREATE INDEX idx_location ON geo USING GIST(coordinates);
```

---

### 🔸 5. **BRIN (Block Range INdex)**

* ⚡ Быстрые и маленькие индексы для **очень больших таблиц**, когда данные отсортированы по колонке.
* Часто применяются к временным меткам.

```sql
CREATE INDEX idx_logs_time ON logs USING BRIN(timestamp);
```

---

### 🔸 Рекомендации по созданию индексов

| Ситуация                                 | Что делать                         |
| ---------------------------------------- | ---------------------------------- |
| Часто используется в `WHERE`             | Добавить B-Tree индекс             |
| Часто используется в `JOIN`              | Индексировать ключи                |
| Часто используется в `ORDER BY`          | Добавить индекс по полю сортировки |
| Поиск по JSONB или массивам              | Использовать GIN                   |
| Большие таблицы с сортированными данными | Использовать BRIN                  |
| Фильтрация по `=`                        | Возможен Hash-индекс               |

---

**Важно:**

* Не индексируйте всё подряд — это увеличит издержки на обновление данных.
* Используйте `EXPLAIN ANALYZE`, чтобы проверить, используется ли индекс.
